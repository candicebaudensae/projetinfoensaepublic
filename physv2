#phys sciences sociales v2

from PyProbs import Probability as pr
import numpy as np
import matplotlib.pyplot as plt
import random as rd
from math import floor
from math import ceil
from math import exp


##fonction utiles
def pbarre(p, Y, t):
    somme1=0
    somme2=0
    for i in range (len(p)):
        somme1=somme1+p[i][t]*Y[i][t]
        somme2=somme2+Y[i][t]
    return (somme1/somme2)

def workforcemax(beta, w, wbarre, t, Nf, i,u):
    haut=exp(beta*w[i][t]/wbarre[t])*Nf*u[t]
    bas=0
    for i in range (len(w)):
        bas=bas+exp(beta*w[i][t]/wbarre(t))
    return (haut/bas)

def wbarre(w, Y, t):
    somme1=0
    somme2=0
    for i in range (len(w)):
        somme1=somme1+w[i][t]*Y[i][t]
        somme2=somme2+Y[i][t]
    return (somme1/somme2)
#remarque on peut faire pbarre(w,Y,t) car c'est la même fonction... à voir si on conserve les deux

def chomage(t, Nf, L):
    somme=0
    for i in range (Nf):
        somme=somme+L[i][t]
    return (1-somme/Nf)

#Li est le nombre d'employés de la firme i

def sommeeps(en_dette, epsilon,t):
    somme=0
    for i in range (len(espilon)):
        if i in en_dette:
            somme=somme+min(epsilon[i][t], 0)
    return (somme)

def somme2eps(V, Y, w):
    somme=0
    for j in (len(V)):
        somme=somme+Y[V[j]][t]*w[V[j]][t]
    return (somme)

def fonction(epsilon, espilond, H, Nf,i,t):
    res=(epsilond[t]-H[t])*epsilon[i][t]
    res2=0
    for i in range (Nf):
        res2=res2+max(epsilon[i][t], 0)
    return (res/res2)

def somme0(Nf, Y, w):
    res=0
    for i in range (Nf):
        res=res+Y[i][t]*w[i][t]
    return (res)

def somme1(div):
    res=0
    for i in range (len(div)):
        res=res+div[i][t]
    return (res)

def calculz(beta, p, pbarrre, t):
    res=0
    for i in range (len(p)):
        res=res+exp(-beta*p[i][t]/pbarre[t])
    return(res)

def calculdeC(p, Y, D, Nf):
    res=0
    for i in range (Nf):
        res=res+p[i][t]*min(Y[i][t], D[i][t])
    return (res)

##déroulé
def  fonctionfinale(Nf, c, beta, gamma, etamoins, etaplus, delta, teta, psi, zeta, temps ): #perturbation est couple [debut, fin, intensité]-> on rajoutera plus tard
    #définition des fonctions
    pbarre=np.zeros(temps)
    wbarre=np.zeros(temps)
    xi=np.zeros((Nf,temps))
    umax=np.zeros((Nf, temps))
    u=np.zeros(temps)
    Y=np.zeros((Nf, temps))
    D=np.zeros((Nf, temps))
    p=np.zeros((Nf, temps))
    div=np.zeros((Nf, temps))
    epsilon=np.zeros((Nf, temps))
    phi=np.zeros((Nf, temps))
    w=np.zeros((Nf, temps))
    en_dette=np.zeros(temps)
    epsilond=np.zeros((Nf, temps))
    V=np.zeros(temps)
    H=np.zeros(temps)
    Cb=np.zeros(temps)
    Z=np.zeros(temps)
    C=np.zeros(temps)
    prof=np.zeros((Nf, temps))

    #conditions initales
    pbarre[0]=1
    wbarre[0]=1
    u[0]=0
    V[0]=[]
    H[0]=0
    Cb[0]=0
    Z[0]=Nf*exp(-beta)
    C[0]=0
    en_dette[0]=[]
    for i in range (Nf):
        xi[i][0]=0
        Y[i][0]=0
        D[i][0]=0
        p[i][0]=1
        prof[i][0]=0
        div[i][0]=0
        epsilon[i][0]=0
        phi[i][0]=0
        epsilond[i][0]=0
        for t in range (temps):
            w[i][t]=1
    for i in range (Nf):
        umax[i][0]=workforcemax(beta, w, wbarre, 0, Nf, i, u)
    for t in range (1, temps):
        pbarre[t]=pbarre(p, Y, t)
        wbarre[t]=wbarre(w, Y, t)
        for i in range (Nf):
            xi[i][t]=rd.random()
            umax[i][t]=workforcemax(beta, w, wbarre, t, Nf, i, u)
            u[t]=1-chomage(t, Nf, L)
            if Y[i][t]<D[i][t]:
                Y[i][t+1]=Y[i][t] + min (etaplus*(D[i][t]-Y[i][t]), umax[i][t])
                if p[i][t]<pbarre[t]:
                    p[i][t+1]=p[i][t](1+gamma*xi[i][t])
                else:
                    p[i][t+1]=p[i][t]
            else:
                Y[i][t+1]=Y[i][t] + max(etamoins*(D[i][t]-Y[i][t]), 0)
                if p[i][t]<=pbarre[t]:
                    p[i][t+1]=p[i][t]
                else:
                    p[i][t+1]=p[i][t](1-gamma*xi[i][t])

            if i not in en_dette:
                Y[i][t]=zeta*L[i][t] #production

                prof[i][t]=p[i][t]*min(Y[i][t], D[i][t])-Y[i][t] #profit

                if prof[i][t]>=0 and epsilon[i][t]>=0:
                    div[i][t]=delta*epsilon[i][t]
                    epsilon[i][t+1]=epsilon[i][t]+prof[i][t]-div[i][t]*heaviside(div[i][t])

                if epsilon[i][t]<0:
                    phi[i][t]=-epsilon[i][t]/(Y[i][t]*w[i][t])

                if phi[i][t]>teta:
                    en_dette.append[i] #on dit qui est ruiné
                    epsilond[t]=epsilond[t]-sommeeps(en_dette, epsilon)
                    epsilon[i][t]=0

            else:
                #on tire avec proba psi dans les interdits pour qui on revit et on update V
                V[t]=[]
                for i in range (len(en_dette)):
                    test=pr.Prob(psi)
                    if test==True:
                        V[t].append(en_dette[i])
                        del en_dette[i] #il n'est plus endetté car on on a eu TRUE
                epsilond[t]=epsilond[t]+somme2eps(V, Y, w)

        if epsilond[t]<=H[t]:
            H[t+1]=H[t]-epsilond[t]
        else:
            H[t+1]=0
            epsilon[i][t+1]=epsilon[i][t] - H[t] -fonction(epsilon, espilond, H, Nf, i, t)


        Cb[t]=c*(H[t]+somme0(Nf, Y, w))

        Z[t]=calculz(beta, p, pbarre, t)

        for i in range (Nf):
            D[i][t]=Cb[t]*exp(-beta*p[i][t]/pbarre[t])/(p[i][t]*Z[t])

        C[t]=calculdeC(p, Y, D, Nf)

        H[t+1]=H[t+1]+somme0(Nf, Y, w) + somme1(div)-C[t] # H représente S les savings

    return (u)



def avecperturbation():

